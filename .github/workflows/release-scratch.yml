name: Release from Scratch

on:
  push:
    branches:
      - release/scratch
  workflow_dispatch:
    inputs:
      wipe_state:
        description: 'Wipe all state (genesis reset)'
        required: true
        default: 'true'
        type: boolean
      skip_build:
        description: 'Skip JAR build (use existing)'
        required: false
        default: 'false'
        type: boolean

env:
  TESSELLATION_VERSION: v4.0.0-rc.2
  JAVA_VERSION: '21'

jobs:
  # ============================================
  # BUILD: Compile JARs
  # ============================================
  build:
    name: Build JARs
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_build != 'true' }}
    
    steps:
      - name: Checkout ottochain-deploy
        uses: actions/checkout@v4
        
      - name: Checkout ottochain
        uses: actions/checkout@v4
        with:
          repository: ottobot-ai/ottochain
          path: ottochain
          
      - name: Checkout tessellation
        uses: actions/checkout@v4
        with:
          repository: Constellation-Labs/tessellation
          ref: ${{ env.TESSELLATION_VERSION }}
          path: tessellation
          
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          
      - name: Setup sbt
        uses: sbt/setup-sbt@v1
          
      - name: Build tessellation SDK
        working-directory: tessellation
        run: |
          # Fix compile error in v4.0.0-rc.2
          FILE="modules/node-shared/src/main/scala/org/tessellation/node/shared/infrastructure/snapshot/GlobalSnapshotStateChannelEventsProcessor.scala"
          if [ -f "$FILE" ] && grep -q "def make\[F\[_\]\]" "$FILE"; then
            sed -i 's/def make\[F\[_\]\]/def make[F[_]]: GlobalSnapshotStateChannelEventsProcessor[F]/g' "$FILE"
          fi
          sbt sdk/publishLocal
          
      - name: Build tessellation JARs (GL0, GL1)
        working-directory: tessellation
        run: sbt dagL0/assembly dagL1/assembly
        
      - name: Build metagraph JARs (ML0, CL1, DL1)
        working-directory: ottochain
        run: sbt assembly
          
      - name: Collect JARs
        run: |
          mkdir -p build
          # Tessellation JARs (named tessellation-dag-l0-assembly-*.jar)
          cp tessellation/modules/dag-l0/target/scala-2.13/tessellation-dag-l0-assembly-*.jar build/dag-l0.jar
          cp tessellation/modules/dag-l1/target/scala-2.13/tessellation-dag-l1-assembly-*.jar build/dag-l1.jar
          # Metagraph JARs
          cp ottochain/modules/l0/target/scala-2.13/ottochain-currency-l0-assembly-*.jar build/metagraph-l0.jar
          cp ottochain/modules/l1/target/scala-2.13/ottochain-currency-l1-assembly-*.jar build/currency-l1.jar
          cp ottochain/modules/data_l1/target/scala-2.13/ottochain-data-l1-assembly-*.jar build/data-l1.jar
          ls -la build/
          
      - name: Upload JARs artifact
        uses: actions/upload-artifact@v4
        with:
          name: jars
          path: build/
          retention-days: 1

  # ============================================
  # DEPLOY: Distribute JARs and start cluster
  # ============================================
  deploy:
    name: Deploy Metagraph
    runs-on: ubuntu-latest
    needs: [build]
    if: always() && (needs.build.result == 'success' || github.event.inputs.skip_build == 'true')
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Download JARs artifact
        if: ${{ github.event.inputs.skip_build != 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: jars
          path: jars/
          
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner
          
          for host in node1 node2 node3 services; do
            case $host in
              node1) ip="${{ secrets.HETZNER_NODE1_IP }}" ;;
              node2) ip="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) ip="${{ secrets.HETZNER_NODE3_IP }}" ;;
              services) ip="${{ secrets.HETZNER_SERVICES_IP }}" ;;
            esac
            cat >> ~/.ssh/config << EOF
          Host $host
            HostName $ip
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF
          done
          
      - name: Stop all containers
        run: |
          echo "=== Stopping all containers ==="
          for host in node1 node2 node3; do
            echo "Stopping $host..."
            ssh $host 'cd /opt/ottochain && docker compose down 2>/dev/null || docker stop $(docker ps -q) 2>/dev/null || true; docker rm -f gl0 gl1 ml0 cl1 dl1 2>/dev/null || true' &
          done
          ssh services 'pm2 stop all 2>/dev/null || true' &
          wait
          echo "All stopped"
          
      - name: Wipe state
        if: ${{ github.event.inputs.wipe_state != 'false' }}
        run: |
          echo "=== Wiping state ==="
          for host in node1 node2 node3; do
            ssh $host 'rm -rf /opt/ottochain/data/* /opt/ottochain/logs/* /opt/ottochain/genesis/genesis.snapshot /opt/ottochain/genesis/genesis.address' &
          done
          wait
          echo "State wiped"
          
      - name: Deploy files to nodes
        run: |
          echo "=== Deploying to nodes ==="
          for host in node1 node2 node3; do
            echo "Deploying to $host..."
            
            # Create directory structure
            ssh $host 'mkdir -p /opt/ottochain/{jars,keys,data,logs,genesis}'
            
            # Copy compose file
            scp docker/metagraph/docker-compose.yml $host:/opt/ottochain/
            
            # Copy JARs if we built them
            if [ -d jars ]; then
              scp jars/*.jar $host:/opt/ottochain/jars/
            fi
          done
          
      - name: Get node peer IDs
        id: peers
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          # Use docker to run show-id with proper keystore credentials
          SHOW_ID_CMD='docker run --rm -v /opt/ottochain/keys:/keys:ro -v /opt/ottochain/jars:/jars:ro -e CL_KEYSTORE=/keys/key.p12 -e CL_PASSWORD='"'$KEYSTORE_PASSWORD'"' -e CL_KEYALIAS=alias eclipse-temurin:21-jdk java -jar /jars/dag-l0.jar show-id'
          
          NODE1_ID=$(ssh node1 "$SHOW_ID_CMD" 2>/dev/null || echo "")
          NODE2_ID=$(ssh node2 "$SHOW_ID_CMD" 2>/dev/null || echo "")
          NODE3_ID=$(ssh node3 "$SHOW_ID_CMD" 2>/dev/null || echo "")
          
          echo "node1_id=$NODE1_ID" >> $GITHUB_OUTPUT
          echo "node2_id=$NODE2_ID" >> $GITHUB_OUTPUT
          echo "node3_id=$NODE3_ID" >> $GITHUB_OUTPUT
          
          echo "Node 1 ID: $NODE1_ID"
          echo "Node 2 ID: $NODE2_ID"
          echo "Node 3 ID: $NODE3_ID"
          
          # Validate that we got peer IDs
          if [ -z "$NODE1_ID" ]; then
            echo "::error::Failed to get peer ID for node1"
            exit 1
          fi

      - name: Create genesis.csv on node1
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        run: |
          SHOW_ADDR_CMD='docker run --rm -v /opt/ottochain/keys:/keys:ro -v /opt/ottochain/jars:/jars:ro -e CL_KEYSTORE=/keys/key.p12 -e CL_PASSWORD='"'$KEYSTORE_PASSWORD'"' -e CL_KEYALIAS=alias eclipse-temurin:21-jdk java -jar /jars/dag-l0.jar show-address'
          NODE1_ADDR=$(ssh node1 "$SHOW_ADDR_CMD" 2>/dev/null || echo "DAG0JjJkmwDn8s9QTyykPRqnvkagxSkrLfDG1mYz")
          echo "Genesis address: $NODE1_ADDR"
          ssh node1 "echo '$NODE1_ADDR,1000000000000000' > /opt/ottochain/genesis/genesis.csv"
          
      - name: Start GL0 genesis (node1)
        run: |
          GENESIS_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          
          # Write complete .env for genesis node (overwrites, not appends)
          ssh node1 << SCRIPT
          cd /opt/ottochain
          cat > .env << EOF
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=$GENESIS_IP
          GL0_PEER_ID=$GL0_PEER_ID
          EOF
          docker compose --profile genesis up -d gl0-genesis
          SCRIPT
          
          echo "Waiting for GL0 to become Ready..."
          for i in {1..60}; do
            state=$(ssh node1 'curl -s http://localhost:9000/node/info 2>/dev/null | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "GL0 is Ready"
              break
            fi
            echo "Waiting... ($i/60) state=$state"
            sleep 5
          done
          
      - name: Start GL0 validators (node2, node3)
        run: |
          GENESIS_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          
          for host in node2 node3; do
            case $host in
              node2) NODE_IP="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) NODE_IP="${{ secrets.HETZNER_NODE3_IP }}" ;;
            esac
            
            # Write complete .env for validator node
            ssh $host << SCRIPT
            cd /opt/ottochain
            cat > .env << EOF
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=$NODE_IP
          GENESIS_IP=$GENESIS_IP
          GL0_PEER_ID=$GL0_PEER_ID
          EOF
            docker compose --profile validator up -d gl0-validator
          SCRIPT
          done
          
          echo "Waiting for GL0 cluster (3 nodes)..."
          for i in {1..60}; do
            count=$(ssh node1 'curl -s http://localhost:9000/cluster/info 2>/dev/null | jq length' || echo "0")
            if [ "$count" = "3" ]; then
              echo "GL0 cluster: $count nodes"
              break
            fi
            echo "Waiting... ($i/60) nodes=$count"
            sleep 5
          done
          
      - name: Start GL1 (all nodes)
        run: |
          GENESIS_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          
          # Genesis node first (GL1 uses same peer ID since same keystore)
          ssh node1 << SCRIPT
          cd /opt/ottochain
          docker compose --profile genesis up -d gl1-initial
          SCRIPT
          
          sleep 30
          
          # Validators
          for host in node2 node3; do
            ssh $host << SCRIPT
            cd /opt/ottochain
            docker compose --profile validator up -d gl1-validator
          SCRIPT
          done
          
          echo "Waiting for GL1 cluster..."
          for i in {1..30}; do
            count=$(ssh node1 'curl -s http://localhost:9100/cluster/info 2>/dev/null | jq length' || echo "0")
            if [ "$count" = "3" ]; then
              echo "GL1 cluster: $count nodes"
              break
            fi
            echo "Waiting... ($i/30) nodes=$count"
            sleep 5
          done
          
      - name: Create ML0 genesis snapshot (node1)
        if: ${{ github.event.inputs.wipe_state != 'false' }}
        run: |
          GENESIS_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          
          ssh node1 << SCRIPT
          cd /opt/ottochain
          
          # Generate genesis snapshot (note: /genesis must be writable, not :ro)
          docker run --rm \
            -v /opt/ottochain/keys:/keys:ro \
            -v /opt/ottochain/data:/data \
            -v /opt/ottochain/jars:/jars:ro \
            -v /opt/ottochain/genesis:/genesis \
            -e CL_KEYSTORE=/keys/key.p12 \
            -e CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }} \
            -e CL_KEYALIAS=alias \
            -e CL_EXTERNAL_IP=$GENESIS_IP \
            -e CL_PUBLIC_HTTP_PORT=9200 \
            -e CL_P2P_HTTP_PORT=9201 \
            -e CL_CLI_HTTP_PORT=9202 \
            -e CL_APP_ENV=dev \
            -e CL_COLLATERAL=0 \
            -e CL_GLOBAL_L0_PEER_ID=$GL0_PEER_ID \
            -e CL_GLOBAL_L0_PEER_HTTP_HOST=$GENESIS_IP \
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
            eclipse-temurin:21-jdk \
            java -jar /jars/metagraph-l0.jar create-genesis /genesis/genesis.csv
          
          # Copy genesis.snapshot to /data for run-genesis command
          cp /opt/ottochain/genesis/genesis.snapshot /opt/ottochain/data/genesis.snapshot
          
          echo "Genesis snapshot created:"
          ls -la /opt/ottochain/genesis/
          ls -la /opt/ottochain/data/genesis.snapshot
          SCRIPT
          
      - name: Start ML0 (all nodes)
        run: |
          GENESIS_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          ML0_PEER_ID="${{ steps.peers.outputs.node1_id }}"
          
          # Update .env on genesis node with ML0_PEER_ID
          ssh node1 << SCRIPT
          cd /opt/ottochain
          cat > .env << EOF
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=$GENESIS_IP
          GL0_PEER_ID=$GL0_PEER_ID
          ML0_PEER_ID=$ML0_PEER_ID
          EOF
          docker compose --profile genesis up -d ml0-genesis
          SCRIPT
          
          echo "Waiting for ML0 to become Ready..."
          for i in {1..60}; do
            state=$(ssh node1 'curl -s http://localhost:9200/node/info 2>/dev/null | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "ML0 is Ready"
              break
            fi
            echo "Waiting... ($i/60) state=$state"
            sleep 5
          done
          
          # Get metagraph ID for TOKEN_ID
          TOKEN_ID=$(ssh node1 'cat /opt/ottochain/genesis/genesis.address' | tr -d '\n')
          echo "Token ID: $TOKEN_ID"
          
          # Update .env on genesis node with TOKEN_ID
          ssh node1 << SCRIPT
          cd /opt/ottochain
          cat > .env << EOF
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=$GENESIS_IP
          GL0_PEER_ID=$GL0_PEER_ID
          ML0_PEER_ID=$ML0_PEER_ID
          TOKEN_ID=$TOKEN_ID
          EOF
          SCRIPT
          
          # Validators
          for host in node2 node3; do
            case $host in
              node2) NODE_IP="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) NODE_IP="${{ secrets.HETZNER_NODE3_IP }}" ;;
            esac
            
            ssh $host << SCRIPT
            cd /opt/ottochain
            cat > .env << EOF
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=$NODE_IP
          GENESIS_IP=$GENESIS_IP
          GL0_PEER_ID=$GL0_PEER_ID
          ML0_PEER_ID=$ML0_PEER_ID
          TOKEN_ID=$TOKEN_ID
          EOF
            docker compose --profile validator up -d ml0-validator
          SCRIPT
          done
          
          echo "Waiting for ML0 cluster..."
          for i in {1..30}; do
            count=$(ssh node1 'curl -s http://localhost:9200/cluster/info 2>/dev/null | jq length' || echo "0")
            if [ "$count" = "3" ]; then
              echo "ML0 cluster: $count nodes"
              break
            fi
            echo "Waiting... ($i/30) nodes=$count"
            sleep 5
          done
          
      - name: Start CL1 (all nodes)
        run: |
          # Genesis first
          ssh node1 << SCRIPT
          cd /opt/ottochain
          docker compose --profile genesis up -d cl1-initial
          SCRIPT
          
          sleep 30
          
          # Validators
          for host in node2 node3; do
            ssh $host << SCRIPT
            cd /opt/ottochain
            docker compose --profile validator up -d cl1-validator
          SCRIPT
          done
          
          echo "Waiting for CL1 cluster..."
          for i in {1..30}; do
            count=$(ssh node1 'curl -s http://localhost:9300/cluster/info 2>/dev/null | jq length' || echo "0")
            if [ "$count" = "3" ]; then
              echo "CL1 cluster: $count nodes"
              break
            fi
            echo "Waiting... ($i/30) nodes=$count"
            sleep 5
          done
          
      - name: Start DL1 (all nodes)
        run: |
          # Genesis first
          ssh node1 << SCRIPT
          cd /opt/ottochain
          docker compose --profile genesis up -d dl1-initial
          SCRIPT
          
          sleep 30
          
          # Validators
          for host in node2 node3; do
            ssh $host << SCRIPT
            cd /opt/ottochain
            docker compose --profile validator up -d dl1-validator
          SCRIPT
          done
          
          echo "Waiting for DL1 cluster..."
          for i in {1..30}; do
            count=$(ssh node1 'curl -s http://localhost:9400/cluster/info 2>/dev/null | jq length' || echo "0")
            if [ "$count" = "3" ]; then
              echo "DL1 cluster: $count nodes"
              break
            fi
            echo "Waiting... ($i/30) nodes=$count"
            sleep 5
          done

      - name: Restart services
        run: |
          ssh services << 'SCRIPT'
          pm2 restart all
          sleep 5
          pm2 list
          SCRIPT

  # ============================================
  # HEALTH CHECK
  # ============================================
  health:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner
          cat >> ~/.ssh/config << EOF
          Host node1
            HostName ${{ secrets.HETZNER_NODE1_IP }}
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          Host services
            HostName ${{ secrets.HETZNER_SERVICES_IP }}
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF
          
      - name: Run health checks
        run: |
          echo "=== OttoChain Health Check ==="
          
          GL0_STATE=$(ssh node1 'curl -s http://localhost:9000/node/info | jq -r .state' 2>/dev/null || echo "UNKNOWN")
          GL0_CLUSTER=$(ssh node1 'curl -s http://localhost:9000/cluster/info | jq length' 2>/dev/null || echo "0")
          
          GL1_CLUSTER=$(ssh node1 'curl -s http://localhost:9100/cluster/info | jq length' 2>/dev/null || echo "0")
          
          ML0_STATE=$(ssh node1 'curl -s http://localhost:9200/node/info | jq -r .state' 2>/dev/null || echo "UNKNOWN")
          ML0_ORDINAL=$(ssh node1 'curl -s http://localhost:9200/snapshots/latest | jq .value.ordinal' 2>/dev/null || echo "0")
          
          CL1_CLUSTER=$(ssh node1 'curl -s http://localhost:9300/cluster/info | jq length' 2>/dev/null || echo "0")
          DL1_CLUSTER=$(ssh node1 'curl -s http://localhost:9400/cluster/info | jq length' 2>/dev/null || echo "0")
          
          EXPLORER=$(ssh services 'curl -s -o /dev/null -w "%{http_code}" http://localhost:8080' 2>/dev/null || echo "000")
          
          echo ""
          echo "GL0: $GL0_STATE (cluster: $GL0_CLUSTER)"
          echo "GL1: cluster=$GL1_CLUSTER"
          echo "ML0: $ML0_STATE (ordinal: $ML0_ORDINAL)"
          echo "CL1: cluster=$CL1_CLUSTER"
          echo "DL1: cluster=$DL1_CLUSTER"
          echo "Explorer: HTTP $EXPLORER"
          
          # Generate summary
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Layer | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| GL0 | $GL0_STATE ($GL0_CLUSTER nodes) |" >> $GITHUB_STEP_SUMMARY
          echo "| GL1 | $GL1_CLUSTER nodes |" >> $GITHUB_STEP_SUMMARY
          echo "| ML0 | $ML0_STATE (ordinal $ML0_ORDINAL) |" >> $GITHUB_STEP_SUMMARY
          echo "| CL1 | $CL1_CLUSTER nodes |" >> $GITHUB_STEP_SUMMARY
          echo "| DL1 | $DL1_CLUSTER nodes |" >> $GITHUB_STEP_SUMMARY
          echo "| Explorer | HTTP $EXPLORER |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Explorer URL**: http://${{ secrets.HETZNER_SERVICES_IP }}:8080" >> $GITHUB_STEP_SUMMARY
