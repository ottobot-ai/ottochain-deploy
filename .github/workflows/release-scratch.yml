name: Release from Scratch

on:
  push:
    branches:
      - release/scratch
      - release/beta
      - release/staging
      - release/prod
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'scratch'
        type: choice
        options:
          - scratch
          - beta
          - staging
          - prod
      wipe_state:
        description: 'Wipe all state (genesis reset)'
        required: true
        default: 'true'
        type: boolean

env:
  TESSELLATION_VERSION: v4.0.0-rc.2
  JAVA_VERSION: '21'

jobs:
  # ============================================
  # BUILD: Compile JARs
  # ============================================
  build:
    name: Build JARs
    runs-on: ubuntu-latest

    steps:
      - name: Checkout ottochain-deploy
        uses: actions/checkout@v4

      - name: Checkout ottochain
        uses: actions/checkout@v4
        with:
          repository: ottobot-ai/ottochain
          path: ottochain

      - name: Checkout tessellation
        uses: actions/checkout@v4
        with:
          repository: Constellation-Labs/tessellation
          ref: ${{ env.TESSELLATION_VERSION }}
          path: tessellation

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}

      - name: Setup sbt
        uses: sbt/setup-sbt@v1

      - name: Build tessellation SDK
        working-directory: tessellation
        run: |
          FILE="modules/node-shared/src/main/scala/org/tessellation/node/shared/infrastructure/snapshot/GlobalSnapshotStateChannelEventsProcessor.scala"
          if [ -f "$FILE" ] && grep -q "def make\[F\[_\]\]" "$FILE"; then
            sed -i 's/def make\[F\[_\]\]/def make[F[_]]: GlobalSnapshotStateChannelEventsProcessor[F]/g' "$FILE"
          fi
          sbt sdk/publishLocal

      - name: Build tessellation JARs (GL0, GL1)
        working-directory: tessellation
        run: sbt dagL0/assembly dagL1/assembly

      - name: Build metagraph JARs (ML0, CL1, DL1)
        working-directory: ottochain
        run: sbt assembly

      - name: Collect JARs
        run: |
          mkdir -p build
          cp tessellation/modules/dag-l0/target/scala-2.13/tessellation-dag-l0-assembly-*.jar build/dag-l0.jar
          cp tessellation/modules/dag-l1/target/scala-2.13/tessellation-dag-l1-assembly-*.jar build/dag-l1.jar
          cp ottochain/modules/l0/target/scala-2.13/ottochain-currency-l0-assembly-*.jar build/metagraph-l0.jar
          cp ottochain/modules/l1/target/scala-2.13/ottochain-currency-l1-assembly-*.jar build/currency-l1.jar
          cp ottochain/modules/data_l1/target/scala-2.13/ottochain-data-l1-assembly-*.jar build/data-l1.jar
          ls -la build/

      - name: Upload JARs artifact
        uses: actions/upload-artifact@v4
        with:
          name: jars
          path: build/
          retention-days: 1

  # ============================================
  # DEPLOY: Full 5-layer cluster deployment
  # ============================================
  deploy:
    name: Deploy Metagraph
    runs-on: ubuntu-latest
    needs: [build]
    if: needs.build.result == 'success'
    outputs:
      gl0_peer_id: ${{ steps.start-gl0.outputs.gl0_peer_id }}
      ml0_peer_id: ${{ steps.start-ml0.outputs.ml0_peer_id }}
      token_id: ${{ steps.create-ml0-genesis.outputs.token_id }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download JARs artifact
        uses: actions/download-artifact@v4
        with:
          name: jars
          path: jars/

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner

          for host in node1 node2 node3 services; do
            case $host in
              node1) ip="${{ secrets.HETZNER_NODE1_IP }}" ;;
              node2) ip="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) ip="${{ secrets.HETZNER_NODE3_IP }}" ;;
              services) ip="${{ secrets.HETZNER_SERVICES_IP }}" ;;
            esac
            cat >> ~/.ssh/config << EOF
          Host $host
            HostName $ip
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF
          done

      # --- Helper function: write .env to a node ---
      - name: Create helper scripts
        run: |
          cat > /tmp/write-env.sh << 'HELPER'
          #!/bin/bash
          # Usage: write-env.sh <host> <node_ip> <genesis_ip> <gl0_id> <ml0_id> <token_id>
          HOST="$1" NODE_IP="$2" GENESIS_IP="$3" GL0_ID="$4" ML0_ID="$5" TOKEN_ID="$6"
          ssh "$HOST" "cat > /opt/ottochain/.env" << ENV_CONTENT
          CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }}
          NODE_IP=${NODE_IP}
          GENESIS_IP=${GENESIS_IP}
          GL0_PEER_ID=${GL0_ID}
          ML0_PEER_ID=${ML0_ID}
          TOKEN_ID=${TOKEN_ID}
          ENV_CONTENT
          HELPER
          chmod +x /tmp/write-env.sh

      # ------------------------------------------
      # PHASE 1: Stop everything and clean up
      # ------------------------------------------
      - name: Stop and remove all containers
        run: |
          for host in node1 node2 node3; do
            ssh $host 'cd /opt/ottochain && docker compose --profile genesis --profile validator down --remove-orphans 2>/dev/null; docker rm -f gl0 gl1 ml0 cl1 dl1 2>/dev/null; true' &
          done
          wait

      - name: Wipe state
        if: ${{ github.event.inputs.wipe_state != 'false' }}
        run: |
          for host in node1 node2 node3; do
            ssh $host 'rm -rf /opt/ottochain/data/* /opt/ottochain/logs/*'
            # Create per-layer data directories
            ssh $host 'mkdir -p /opt/ottochain/data/{ml0,cl1,dl1}'
          done

      # ------------------------------------------
      # PHASE 2: Deploy files to all nodes
      # ------------------------------------------
      - name: Deploy files to nodes
        run: |
          for host in node1 node2 node3; do
            ssh $host 'mkdir -p /opt/ottochain/{jars,keys,data,logs,genesis} /opt/ottochain/data/{ml0,cl1,dl1}'
            scp docker/metagraph/docker-compose.yml $host:/opt/ottochain/
            ssh $host 'rm -f /opt/ottochain/docker-compose.override.yml'
            scp jars/*.jar $host:/opt/ottochain/jars/
          done

      # ------------------------------------------
      # PHASE 3: Create genesis artifacts (node1)
      # ------------------------------------------
      - name: Create genesis artifacts
        if: ${{ github.event.inputs.wipe_state != 'false' }}
        run: |
          ssh node1 << 'GENESIS_SCRIPT'
          cd /opt/ottochain

          WALLET=$(docker run --rm \
            -v /opt/ottochain/keys:/keys:ro \
            -v /opt/ottochain/jars:/jars:ro \
            -e CL_KEYSTORE=/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD=password \
            eclipse-temurin:21-jdk \
            java -jar /jars/cl-wallet.jar show-address 2>/dev/null | grep -oP 'DAG[a-zA-Z0-9]+' || true)

          if [ -z "$WALLET" ]; then
            WALLET=$(docker run --rm \
              -v /opt/ottochain/keys:/keys:ro \
              -v /opt/ottochain/jars:/jars:ro \
              -e CL_KEYSTORE=/keys/key.p12 \
              -e CL_KEYALIAS=alias \
              -e CL_PASSWORD=password \
              eclipse-temurin:21-jdk \
              java -jar /jars/dag-l0.jar show-address 2>/dev/null | grep -oP 'DAG[a-zA-Z0-9]+' || true)
          fi

          echo "Genesis wallet: $WALLET"
          echo "$WALLET,1000000000000000" > genesis/genesis.csv

          docker run --rm \
            -v /opt/ottochain/keys:/keys:ro \
            -v /opt/ottochain/jars:/jars:ro \
            -v /opt/ottochain/genesis:/genesis \
            -v /opt/ottochain/data:/data \
            -e CL_KEYSTORE=/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD=password \
            eclipse-temurin:21-jdk \
            java -jar /jars/metagraph-l0.jar create-genesis /genesis/genesis.csv

          cp -f genesis/genesis.snapshot data/genesis.snapshot 2>/dev/null || true
          ls -la genesis/ data/
          GENESIS_SCRIPT

      # ------------------------------------------
      # PHASE 4: Start GL0 (Global L0)
      # ------------------------------------------
      - name: Start GL0
        id: start-gl0
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"

          # Write initial .env for GL0 genesis (placeholder peer IDs are fine â€” GL0 genesis doesn't need them)
          /tmp/write-env.sh node1 "$NODE1_IP" "$NODE1_IP" "placeholder" "placeholder" "placeholder"
          ssh node1 "cd /opt/ottochain && docker compose --profile genesis up -d gl0-genesis"

          echo "Waiting for GL0 to become Ready..."
          for i in $(seq 1 90); do
            state=$(ssh node1 'curl -sf http://localhost:9000/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "GL0 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "90" ]; then echo "::error::GL0 failed to reach Ready"; exit 1; fi
            sleep 5
          done

          # Capture GL0 peer ID
          GL0_PEER_ID=$(ssh node1 'curl -sf http://localhost:9000/node/info | jq -r .id')
          echo "gl0_peer_id=$GL0_PEER_ID" >> "$GITHUB_OUTPUT"
          echo "GL0 Peer ID: ${GL0_PEER_ID:0:24}..."
          ssh node1 "echo '$GL0_PEER_ID' > /opt/ottochain/gl0-peer-id"

          # IMPORTANT: Update node1's .env with real GL0_PEER_ID before any other layer starts
          /tmp/write-env.sh node1 "$NODE1_IP" "$NODE1_IP" "$GL0_PEER_ID" "placeholder" "placeholder"

          # Start GL0 validators on node2, node3
          for host_info in "node2:${NODE2_IP}" "node3:${NODE3_IP}"; do
            HOST="${host_info%%:*}"
            IP="${host_info##*:}"
            /tmp/write-env.sh "$HOST" "$IP" "$NODE1_IP" "$GL0_PEER_ID" "placeholder" "placeholder"
            ssh "$HOST" "cd /opt/ottochain && docker compose --profile validator up -d gl0-validator"
          done

          sleep 20

          # Join validators to GL0 cluster
          for host in node2 node3; do
            echo "Joining $host to GL0..."
            ssh "$host" "curl -sf -X POST http://127.0.0.1:9002/cluster/join \
              -H 'Content-Type: application/json' \
              -d '{\"id\": \"${GL0_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9001}'" || true
          done

          sleep 15
          GL0_CLUSTER=$(ssh node1 'curl -sf http://localhost:9000/cluster/info | jq length')
          echo "GL0 cluster size: $GL0_CLUSTER"

      # ------------------------------------------
      # PHASE 5: Start GL1 (Global L1)
      # ------------------------------------------
      - name: Start GL1
        id: start-gl1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # GL1 initial-validator on node1 (reads GL0_PEER_ID from .env which is now correct)
          ssh node1 "cd /opt/ottochain && docker compose --profile genesis up -d gl1-initial"

          echo "Waiting for GL1..."
          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9100/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "GL1 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "60" ]; then echo "::warning::GL1 did not reach Ready (single-node is expected)"; break; fi
            sleep 5
          done

          GL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9100/node/info | jq -r .id' || echo "")
          echo "gl1_peer_id=$GL1_PEER_ID" >> "$GITHUB_OUTPUT"

          # GL1 validators on node2, node3
          for host in node2 node3; do
            ssh "$host" "cd /opt/ottochain && docker compose --profile validator up -d gl1-validator"
          done

          sleep 20

          # Join GL1 validators
          if [ -n "$GL1_PEER_ID" ] && [ "$GL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              echo "Joining $host to GL1..."
              ssh "$host" "curl -sf -X POST http://127.0.0.1:9102/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${GL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9101}'" || true
            done
          fi

          sleep 10
          GL1_CLUSTER=$(ssh node1 'curl -sf http://localhost:9100/cluster/info | jq length' || echo "0")
          echo "GL1 cluster size: $GL1_CLUSTER"

      # ------------------------------------------
      # PHASE 6: Create ML0 genesis snapshot
      # ------------------------------------------
      - name: Create ML0 genesis snapshot
        id: create-ml0-genesis
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          echo "Creating ML0 genesis snapshot..."
          ssh node1 << GENESIS_SCRIPT
          cd /opt/ottochain
          source .env

          # Run create-genesis to create genesis.snapshot
          docker run --rm \\
            -v /opt/ottochain/keys:/keys:ro \\
            -v /opt/ottochain/jars:/jars:ro \\
            -v /opt/ottochain/genesis:/genesis \\
            -v /opt/ottochain/data:/data \\
            -e CL_KEYSTORE=/keys/key.p12 \\
            -e CL_KEYALIAS=alias \\
            -e CL_PASSWORD="\$CL_PASSWORD" \\
            -e CL_EXTERNAL_IP="\$NODE_IP" \\
            -e CL_APP_ENV=dev \\
            -e CL_COLLATERAL=0 \\
            -e CL_PUBLIC_HTTP_PORT=9200 \\
            -e CL_P2P_HTTP_PORT=9201 \\
            -e CL_CLI_HTTP_PORT=9202 \\
            -e CL_GLOBAL_L0_PEER_ID="\$GL0_PEER_ID" \\
            -e CL_GLOBAL_L0_PEER_HTTP_HOST="\$NODE_IP" \\
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \\
            eclipse-temurin:21-jdk \\
            java -jar /jars/metagraph-l0.jar create-genesis /genesis/genesis.csv
          GENESIS_SCRIPT

          # Verify genesis.snapshot was created
          ssh node1 "ls -la /opt/ottochain/genesis/genesis.snapshot" || { echo "::error::genesis.snapshot not created"; exit 1; }

          # Copy to /data for run-genesis
          ssh node1 "cp /opt/ottochain/genesis/genesis.snapshot /opt/ottochain/data/"

          # Get the metagraph address (TOKEN_ID) from genesis.address
          TOKEN_ID=$(ssh node1 "cat /opt/ottochain/genesis/genesis.address")
          echo "Metagraph address (TOKEN_ID): $TOKEN_ID"
          echo "token_id=$TOKEN_ID" >> "$GITHUB_OUTPUT"
          ssh node1 "echo '$TOKEN_ID' > /opt/ottochain/token-id"

      # ------------------------------------------
      # PHASE 7: Start ML0 (Metagraph L0)
      # ------------------------------------------
      - name: Start ML0
        id: start-ml0
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # ML0 genesis on node1 (genesis.snapshot now exists in /data)
          ssh node1 "cd /opt/ottochain && docker compose --profile genesis up -d ml0-genesis"

          echo "Waiting for ML0 to become Ready..."
          for i in $(seq 1 90); do
            state=$(ssh node1 'curl -sf http://localhost:9200/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "ML0 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "90" ]; then echo "::error::ML0 failed to reach Ready"; exit 1; fi
            sleep 5
          done

          # Capture ML0 peer ID
          ML0_PEER_ID=$(ssh node1 'curl -sf http://localhost:9200/node/info | jq -r .id')
          echo "ml0_peer_id=$ML0_PEER_ID" >> "$GITHUB_OUTPUT"
          echo "ML0 Peer ID: ${ML0_PEER_ID:0:24}..."
          ssh node1 "echo '$ML0_PEER_ID' > /opt/ottochain/ml0-peer-id"

          # TOKEN_ID already set in create-ml0-genesis step
          TOKEN_ID=$(ssh node1 "cat /opt/ottochain/token-id")
          echo "Token ID: $TOKEN_ID"

          # Write COMPLETE .env on ALL nodes with all IDs resolved
          /tmp/write-env.sh node1 "$NODE1_IP" "$NODE1_IP" "$GL0_PEER_ID" "$ML0_PEER_ID" "$TOKEN_ID"
          /tmp/write-env.sh node2 "$NODE2_IP" "$NODE1_IP" "$GL0_PEER_ID" "$ML0_PEER_ID" "$TOKEN_ID"
          /tmp/write-env.sh node3 "$NODE3_IP" "$NODE1_IP" "$GL0_PEER_ID" "$ML0_PEER_ID" "$TOKEN_ID"

          # ML0 validators on node2, node3
          for host in node2 node3; do
            ssh "$host" "cd /opt/ottochain && docker compose --profile validator up -d ml0-validator"
          done

          sleep 25

          # Join ML0 validators
          for host in node2 node3; do
            echo "Joining $host to ML0..."
            ssh "$host" "curl -sf -X POST http://127.0.0.1:9202/cluster/join \
              -H 'Content-Type: application/json' \
              -d '{\"id\": \"${ML0_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9201}'" || true
          done

          sleep 15
          ML0_CLUSTER=$(ssh node1 'curl -sf http://localhost:9200/cluster/info | jq length' || echo "0")
          echo "ML0 cluster size: $ML0_CLUSTER"

      # ------------------------------------------
      # PHASE 7: Start CL1 (Currency L1)
      # ------------------------------------------
      - name: Start CL1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"

          # CL1 initial-validator on node1
          ssh node1 "cd /opt/ottochain && docker compose --profile genesis up -d cl1-initial"

          echo "Waiting for CL1..."
          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9300/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "CL1 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "60" ]; then echo "::warning::CL1 did not reach Ready"; break; fi
            sleep 5
          done

          CL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9300/node/info | jq -r .id' || echo "")

          # CL1 validators on node2, node3
          for host in node2 node3; do
            ssh "$host" "cd /opt/ottochain && docker compose --profile validator up -d cl1-validator"
          done

          sleep 25

          # Join CL1 validators
          if [ -n "$CL1_PEER_ID" ] && [ "$CL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              echo "Joining $host to CL1..."
              ssh "$host" "curl -sf -X POST http://127.0.0.1:9302/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${CL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9301}'" || true
            done
          fi

          sleep 10
          CL1_CLUSTER=$(ssh node1 'curl -sf http://localhost:9300/cluster/info | jq length' || echo "0")
          echo "CL1 cluster size: $CL1_CLUSTER"

      # ------------------------------------------
      # PHASE 8: Start DL1 (Data L1)
      # ------------------------------------------
      - name: Start DL1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"

          # DL1 initial-validator on node1
          ssh node1 "cd /opt/ottochain && docker compose --profile genesis up -d dl1-initial"

          echo "Waiting for DL1..."
          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9400/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "DL1 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "60" ]; then echo "::warning::DL1 did not reach Ready"; break; fi
            sleep 5
          done

          DL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9400/node/info | jq -r .id' || echo "")

          # DL1 validators on node2, node3
          for host in node2 node3; do
            ssh "$host" "cd /opt/ottochain && docker compose --profile validator up -d dl1-validator"
          done

          sleep 25

          # Join DL1 validators
          if [ -n "$DL1_PEER_ID" ] && [ "$DL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              echo "Joining $host to DL1..."
              ssh "$host" "curl -sf -X POST http://127.0.0.1:9402/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${DL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9401}'" || true
            done
          fi

          sleep 10
          DL1_CLUSTER=$(ssh node1 'curl -sf http://localhost:9400/cluster/info | jq length' || echo "0")
          echo "DL1 cluster size: $DL1_CLUSTER"

  # ============================================
  # SERVICES: Deploy indexer, explorer, monitor
  # ============================================
  services:
    name: Deploy Services
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner
          cat >> ~/.ssh/config << EOF
          Host services
            HostName ${{ secrets.HETZNER_SERVICES_IP }}
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF

      - name: Reset database and Redis
        if: ${{ github.event.inputs.wipe_state != 'false' }}
        run: |
          echo "Flushing Postgres and Redis (if running)..."
          ssh services << 'RESET_SCRIPT'
          # Flush Redis (container might be from compose or standalone)
          docker exec redis redis-cli FLUSHALL 2>/dev/null && echo "âœ“ Redis flushed" || echo "â„¹ Redis not running yet"
          
          # Truncate Postgres tables
          docker exec postgres psql -U ottochain -d ottochain -c "
            DO \$\$
            DECLARE
              r RECORD;
            BEGIN
              FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE 'TRUNCATE TABLE \"' || r.tablename || '\" CASCADE';
              END LOOP;
            END \$\$;
          " 2>/dev/null && echo "âœ“ Postgres tables truncated" || echo "â„¹ Postgres not running yet"
          RESET_SCRIPT

      - name: Deploy services stack
        run: |
          METAGRAPH_IP="${{ secrets.HETZNER_NODE1_IP }}"
          SERVICES_IP="${{ secrets.HETZNER_SERVICES_IP }}"

          # Write .env for docker compose
          ssh services "cat > /opt/ottochain-services/.env" << SERVICES_ENV
          # Database
          DATABASE_URL=postgresql://ottochain:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/ottochain
          POSTGRES_USER=ottochain
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=ottochain

          # Metagraph endpoints
          METAGRAPH_ML0_URL=http://${METAGRAPH_IP}:9200
          METAGRAPH_DL1_URL=http://${METAGRAPH_IP}:9400
          GL0_URL=http://${METAGRAPH_IP}:9000
          GL1_URL=http://${METAGRAPH_IP}:9100
          ML0_URL=http://${METAGRAPH_IP}:9200
          CL1_URL=http://${METAGRAPH_IP}:9300
          DL1_URL=http://${METAGRAPH_IP}:9400

          # Alerting
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_ALERT_BOT_TOKEN }}
          TELEGRAM_CHAT_ID=${{ secrets.TELEGRAM_ALERT_CHAT_ID }}

          # Version pinning (optional, defaults to latest)
          # SERVICES_VERSION=v0.2.0
          # EXPLORER_VERSION=v0.1.0
          SERVICES_ENV

          ssh services << 'DEPLOY_SCRIPT'
          cd /opt/ottochain-services
          git pull origin main || true
          
          # Stop PM2 if running (migration from old setup)
          pm2 stop all 2>/dev/null || true
          pm2 delete all 2>/dev/null || true
          
          # Pull latest images and deploy stack
          docker compose pull
          docker compose up -d
          
          # Run database migrations
          docker compose exec -T indexer npx prisma db push --accept-data-loss || true
          
          # Show status
          docker compose ps
          DEPLOY_SCRIPT

      - name: Update nginx config
        run: |
          ssh services << 'NGINX_SCRIPT'
          # Update nginx to proxy to Docker containers
          cat > /etc/nginx/sites-available/ottochain << 'NGINX_CONF'
          server {
              listen 8080;
              server_name _;

              location /graphql {
                  proxy_pass http://127.0.0.1:4000/graphql;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
              }

              location /api/ {
                  proxy_pass http://127.0.0.1:3030/;
              }

              location /webhook/ {
                  proxy_pass http://127.0.0.1:3031/;
              }

              location /monitor/ {
                  proxy_pass http://127.0.0.1:3032/;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                  proxy_set_header Host $host;
              }

              location / {
                  proxy_pass http://127.0.0.1:8081;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
              }
          }
          NGINX_CONF
          
          ln -sf /etc/nginx/sites-available/ottochain /etc/nginx/sites-enabled/ottochain
          nginx -t && nginx -s reload
          echo "Nginx updated"
          NGINX_SCRIPT

  # ============================================
  # HEALTH CHECK: Verify all layers are up
  # ============================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy, services]
    if: always()

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner
          cat >> ~/.ssh/config << EOF
          Host node1
            HostName ${{ secrets.HETZNER_NODE1_IP }}
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          Host services
            HostName ${{ secrets.HETZNER_SERVICES_IP }}
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF

      - name: Check all layers
        run: |
          echo "=== OttoChain 5-Layer Cluster Health ==="
          FAILED=0

          for layer in gl0 gl1 ml0 cl1 dl1; do
            case $layer in
              gl0) port=9000 ;; gl1) port=9100 ;; ml0) port=9200 ;; cl1) port=9300 ;; dl1) port=9400 ;;
            esac
            state=$(ssh node1 "curl -sf http://localhost:$port/node/info | jq -r .state" || echo "DOWN")
            cluster=$(ssh node1 "curl -sf http://localhost:$port/cluster/info | jq length" || echo "0")
            STATUS="âœ…"
            if [ "$state" != "Ready" ]; then STATUS="âŒ"; FAILED=$((FAILED + 1)); fi
            echo "$STATUS $layer: $state (cluster: $cluster)"
          done

          EXPLORER=$(ssh services 'curl -sf -o /dev/null -w "%{http_code}" http://localhost:8080' || echo "000")
          echo "Explorer: HTTP $EXPLORER"

          if [ "$FAILED" -gt 0 ]; then echo "::warning::$FAILED layer(s) not Ready"; fi

      - name: Verify currency state
        run: |
          echo "=== Verifying Currency State ==="
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          
          # Get genesis wallet from the key
          GENESIS_WALLET=$(ssh node1 "docker run --rm \
            -v /opt/ottochain/keys:/keys:ro \
            -v /opt/ottochain/jars:/jars:ro \
            -e CL_KEYSTORE=/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_PASSWORD }}' \
            eclipse-temurin:21-jdk \
            java -jar /jars/metagraph-l0.jar export-wallet" 2>/dev/null | tail -1 || echo "UNKNOWN")
          echo "Genesis wallet: $GENESIS_WALLET"
          
          # Check ML0 has genesis balance
          ML0_BALANCE=$(ssh node1 "curl -sf http://localhost:9200/currency/${GENESIS_WALLET}/balance | jq -r '.balance // 0'" || echo "0")
          echo "ML0 balance: $ML0_BALANCE"
          
          # Check ML0 ordinal is progressing
          ML0_ORDINAL=$(ssh node1 "curl -sf http://localhost:9200/snapshots/latest | jq -r '.value.ordinal // 0'" || echo "0")
          echo "ML0 ordinal: $ML0_ORDINAL"
          
          # Verify basic health
          if [ "$ML0_BALANCE" = "0" ] || [ "$ML0_BALANCE" = "null" ]; then
            echo "::error::Genesis wallet has no balance on ML0"
            exit 1
          fi
          
          if [ "$ML0_ORDINAL" = "0" ]; then
            echo "::warning::ML0 has no snapshots yet"
          fi
          
          echo "âœ… Currency state verified"

      - name: Summary
        if: always()
        run: |
          echo "## ðŸš€ OttoChain Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Layer | Port | State | Cluster |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|-------|---------|" >> $GITHUB_STEP_SUMMARY

          for layer in GL0 GL1 ML0 CL1 DL1; do
            case $layer in
              GL0) port=9000 ;; GL1) port=9100 ;; ML0) port=9200 ;; CL1) port=9300 ;; DL1) port=9400 ;;
            esac
            state=$(ssh node1 "curl -sf http://localhost:$port/node/info | jq -r .state" 2>/dev/null || echo "?")
            cluster=$(ssh node1 "curl -sf http://localhost:$port/cluster/info | jq length" 2>/dev/null || echo "?")
            ICON="âœ…"; [ "$state" != "Ready" ] && ICON="âŒ"
            echo "| $ICON $layer | $port | $state | $cluster |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**GL0 Peer ID**: \`${{ needs.deploy.outputs.gl0_peer_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Token ID**: \`${{ needs.deploy.outputs.token_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Explorer**: http://${{ secrets.HETZNER_SERVICES_IP }}:8080" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # COMPATIBILITY: Update compatibility matrix
  # ============================================
  compatibility:
    name: Update Compatibility
    runs-on: ubuntu-latest
    needs: [services]
    if: success()
    
    steps:
      - name: Compute target branch and environment
        id: target
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Extract environment from branch name (release/scratch -> scratch)
            TARGET_BRANCH="${{ github.ref_name }}"
            TARGET_ENV="${TARGET_BRANCH#release/}"
          else
            TARGET_ENV="${{ inputs.environment }}"
            TARGET_BRANCH="release/${TARGET_ENV}"
          fi
          echo "branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"
          echo "env=$TARGET_ENV" >> "$GITHUB_OUTPUT"
          echo "Target: $TARGET_BRANCH ($TARGET_ENV)"

      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.target.outputs.branch }}

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Generate compatibility matrix
        run: |
          chmod +x scripts/generate-compatibility.sh
          ./scripts/generate-compatibility.sh

      - name: Update deployed versions
        env:
          TARGET_ENV: ${{ steps.target.outputs.env }}
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          yq -i ".deployed.${TARGET_ENV}.ottochain = .components.ottochain.version" versions.yml
          yq -i ".deployed.${TARGET_ENV}.services = .components.services.version" versions.yml
          yq -i ".deployed.${TARGET_ENV}.explorer = .components.explorer.version" versions.yml
          yq -i ".deployed.${TARGET_ENV}.timestamp = \"$TIMESTAMP\"" versions.yml
          yq -i ".deployed.${TARGET_ENV}.workflow_run = \"${{ github.run_id }}\"" versions.yml

      - name: Commit changes
        env:
          TARGET_BRANCH: ${{ steps.target.outputs.branch }}
          TARGET_ENV: ${{ steps.target.outputs.env }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add COMPATIBILITY.md versions.yml
          git diff --staged --quiet || git commit -m "chore: update ${TARGET_ENV} compatibility matrix [skip ci]"
          git push origin "${TARGET_BRANCH}"
