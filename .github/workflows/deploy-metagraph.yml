name: Deploy Metagraph

# Prevent concurrent deployments to the same environment
# Note: inputs.environment works for both workflow_dispatch and workflow_call
concurrency:
  group: deploy-metagraph-${{ inputs.environment || 'scratch' }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'scratch'
        type: choice
        options:
          - scratch
          - beta
          - staging
          - prod
      wipe_state:
        description: 'Wipe all state (genesis reset)'
        required: true
        default: 'false'
        type: boolean
      image_tag:
        description: 'Docker image tag (default: latest)'
        required: false
        default: 'latest'
        type: string
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      wipe_state:
        required: false
        type: boolean
        default: false
      image_tag:
        required: false
        type: string
        default: 'latest'

env:
  # Single image with all 5 layers (tessellation + metagraph)
  # Ensures version compatibility
  IMAGE: ghcr.io/scasplte2/ottochain-metagraph
  IMAGE_TAG: ${{ inputs.image_tag || 'latest' }}

jobs:
  deploy:
    name: Deploy Full Stack
    runs-on: ubuntu-latest
    outputs:
      gl0_peer_id: ${{ steps.start-gl0.outputs.gl0_peer_id }}
      ml0_peer_id: ${{ steps.start-ml0.outputs.ml0_peer_id }}
      token_id: ${{ steps.start-ml0.outputs.token_id }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner

          for host in node1 node2 node3; do
            case $host in
              node1) ip="${{ secrets.HETZNER_NODE1_IP }}" ;;
              node2) ip="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) ip="${{ secrets.HETZNER_NODE3_IP }}" ;;
            esac
            cat >> ~/.ssh/config << EOF
          Host $host
            HostName $ip
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF
          done

      - name: Login to GHCR on all nodes
        run: |
          for host in node1 node2 node3; do
            ssh $host "echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u ottobot-ai --password-stdin" &
          done
          wait
          echo "âœ… GHCR login complete on all nodes"

      - name: Pull image on all nodes
        run: |
          for host in node1 node2 node3; do
            echo "Pulling image on $host..."
            ssh $host "docker pull ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}" &
          done
          wait
          echo "âœ… Image pulled on all nodes"

      - name: Stop all containers
        run: |
          for host in node1 node2 node3; do
            # Also stop node-exporter which uses port 9100 (conflicts with GL1)
            ssh $host 'docker rm -f gl0 gl1 ml0 cl1 dl1 node-exporter 2>/dev/null || true' &
          done
          wait

      - name: Setup and verify keys on all nodes
        run: |
          echo "=== Setting up L1 consensus keys ==="
          # L1 nodes need DIFFERENT keys for consensus - same key = same peer ID = no consensus
          # Node1 stores the master keys (key.p12, key2.p12, key3.p12)
          # Node2 uses keys2/key.p12, Node3 uses keys3/key.p12
          
          # Verify node1 has the source keys
          ssh node1 'test -f /opt/ottochain/keys/key.p12 || (echo "ERROR: key.p12 not found on node1"; exit 1)'
          echo "âœ“ node1: source key.p12 exists"
          
          # Distribute key2.p12 to node2 if missing
          if ! ssh node2 'test -f /opt/ottochain/keys2/key.p12' 2>/dev/null; then
            echo "Distributing key2 to node2..."
            ssh node2 'mkdir -p /opt/ottochain/keys2'
            if ssh node1 'test -f /opt/ottochain/keys/key2.p12'; then
              ssh node1 'cat /opt/ottochain/keys/key2.p12' | ssh node2 'cat > /opt/ottochain/keys2/key.p12 && chmod 644 /opt/ottochain/keys2/key.p12'
              echo "âœ“ Copied key2.p12 from node1 to node2/keys2/"
            else
              echo "ERROR: key2.p12 not found on node1 - cannot setup node2"
              exit 1
            fi
          else
            echo "âœ“ node2: keys2/key.p12 already exists"
          fi
          
          # Distribute key3.p12 to node3 if missing
          if ! ssh node3 'test -f /opt/ottochain/keys3/key.p12' 2>/dev/null; then
            echo "Distributing key3 to node3..."
            ssh node3 'mkdir -p /opt/ottochain/keys3'
            if ssh node1 'test -f /opt/ottochain/keys/key3.p12'; then
              ssh node1 'cat /opt/ottochain/keys/key3.p12' | ssh node3 'cat > /opt/ottochain/keys3/key.p12 && chmod 644 /opt/ottochain/keys3/key.p12'
              echo "âœ“ Copied key3.p12 from node1 to node3/keys3/"
            else
              echo "ERROR: key3.p12 not found on node1 - cannot setup node3"
              exit 1
            fi
          else
            echo "âœ“ node3: keys3/key.p12 already exists"
          fi
          
          echo ""
          echo "All keys verified. L1 consensus should work."

      - name: Detect if genesis is needed
        id: genesis-check
        run: |
          # Genesis is required if:
          # 1. wipe_state is explicitly true, OR
          # 2. genesis.address doesn't exist (fresh deploy / no prior genesis)
          WIPE="${{ inputs.wipe_state }}"
          if [ "$WIPE" = "true" ]; then
            echo "needs_genesis=true" >> $GITHUB_OUTPUT
            echo "Genesis required: wipe_state=true"
          elif ! ssh node1 'test -f /opt/ottochain/genesis/genesis.address' 2>/dev/null; then
            echo "needs_genesis=true" >> $GITHUB_OUTPUT
            echo "Genesis required: genesis.address not found"
          else
            echo "needs_genesis=false" >> $GITHUB_OUTPUT
            echo "Genesis not required: existing genesis.address found"
            ssh node1 'cat /opt/ottochain/genesis/genesis.address'
          fi

      - name: Wipe state
        if: ${{ inputs.wipe_state == true }}
        run: |
          # Only wipe when explicitly requested (not just because genesis is missing)
          # Use layer-specific data and log directories to avoid conflicts between GL0/ML0/etc
          for host in node1 node2 node3; do
            ssh $host 'rm -rf /opt/ottochain/gl0-data /opt/ottochain/gl1-data /opt/ottochain/ml0-data /opt/ottochain/cl1-data /opt/ottochain/dl1-data /opt/ottochain/genesis/*'
            ssh $host 'rm -rf /opt/ottochain/gl0-logs /opt/ottochain/gl1-logs /opt/ottochain/ml0-logs /opt/ottochain/cl1-logs /opt/ottochain/dl1-logs'
            ssh $host 'mkdir -p /opt/ottochain/{gl0-data,gl1-data,ml0-data,cl1-data,dl1-data,keys,genesis}'
            ssh $host 'mkdir -p /opt/ottochain/{gl0-logs,gl1-logs,ml0-logs,cl1-logs,dl1-logs}'
          done

      - name: Prepare directories
        run: |
          for host in node1 node2 node3; do
            ssh $host 'mkdir -p /opt/ottochain/{gl0-data,gl1-data,ml0-data,cl1-data,dl1-data,keys,genesis}'
            ssh $host 'mkdir -p /opt/ottochain/{gl0-logs,gl1-logs,ml0-logs,cl1-logs,dl1-logs}'
          done

      # NOTE: In tessellation v4.x:
      # - GL0 run-genesis requires a genesis CSV file with initial balances
      # - ML0 create-genesis requires GL0 to be running
      
      - name: Create GL0 genesis file
        if: ${{ steps.genesis-check.outputs.needs_genesis == 'true' }}
        run: |
          # Download cl-wallet.jar for wallet address extraction
          ssh node1 "test -f /opt/ottochain/cl-wallet.jar || curl -sL -o /opt/ottochain/cl-wallet.jar \
            https://github.com/Constellation-Labs/tessellation/releases/download/v4.0.0-rc.2/cl-wallet.jar"
          
          # Get wallet address
          WALLET=$(ssh node1 "CL_KEYSTORE=/opt/ottochain/keys/key.p12 CL_KEYALIAS=alias CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            java -jar /opt/ottochain/cl-wallet.jar show-address" 2>&1 | grep -oP 'DAG[a-zA-Z0-9]+' | head -1)
          
          echo "GL0 genesis wallet: $WALLET"
          
          # Create genesis.csv for GL0 (DAG initial balances)
          ssh node1 "echo '${WALLET},1000000000000000' > /opt/ottochain/genesis/gl0-genesis.csv"
          ssh node1 "cat /opt/ottochain/genesis/gl0-genesis.csv"
          echo "âœ… GL0 genesis file created"

      - name: Start GL0 Genesis
        id: start-gl0
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          
          # Use entrypoint with IS_INITIAL=true - auto-detects run-genesis vs run-rollback
          # Genesis file at /ottochain/genesis/gl0-genesis.csv is auto-discovered
          ssh node1 "docker run -d --name gl0 \
            --restart unless-stopped \
            --log-opt max-size=100m --log-opt max-file=3 \
            -p 9000:9000 -p 9001:9001 -p 9002:9002 \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/gl0-data:/ottochain/data \
            -v /opt/ottochain/gl0-logs:/tessellation/logs \
            -v /opt/ottochain/genesis:/ottochain/genesis:ro \
            -e LAYER=gl0 \
            -e IS_INITIAL=true \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            -e CL_COLLATERAL=0 \
            -e CL_KEYSTORE=/ottochain/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            -e JAVA_OPTS='-Xmx8g -Xms4g' \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"

          echo "Waiting for GL0 to become Ready..."
          for i in $(seq 1 90); do
            state=$(ssh node1 'curl -sf http://localhost:9000/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "GL0 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "90" ]; then echo "::error::GL0 failed to reach Ready"; exit 1; fi
            sleep 5
          done

          GL0_PEER_ID=$(ssh node1 'curl -sf http://localhost:9000/node/info | jq -r .id')
          echo "gl0_peer_id=$GL0_PEER_ID" >> "$GITHUB_OUTPUT"
          echo "GL0 Peer ID: $GL0_PEER_ID"

      - name: Start GL0 Validators
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # CRITICAL: Each node needs a DIFFERENT key for consensus
          # node2 uses keys2, node3 uses keys3
          for host_info in "node2:${NODE2_IP}:keys2" "node3:${NODE3_IP}:keys3"; do
            HOST="${host_info%%:*}"
            rest="${host_info#*:}"
            IP="${rest%%:*}"
            KEYS="${rest##*:}"

            # IS_INITIAL not set = auto-detects run-validator
            ssh $HOST "docker run -d --name gl0 \
              --restart unless-stopped \
              --log-opt max-size=100m --log-opt max-file=3 \
              -p 9000:9000 -p 9001:9001 -p 9002:9002 \
              -v /opt/ottochain/${KEYS}:/ottochain/keys:ro \
              -v /opt/ottochain/gl0-data:/ottochain/data \
              -v /opt/ottochain/gl0-logs:/tessellation/logs \
              -e LAYER=gl0 \
              -e CL_APP_ENV=dev \
              -e CL_EXTERNAL_IP=${IP} \
              -e CL_COLLATERAL=0 \
              -e CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }} \
              -e JAVA_OPTS='-Xmx8g -Xms4g' \
              ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"
          done

          sleep 20

          # CLI port binds to container's 127.0.0.1, must use docker exec
          for host in node2 node3; do
            ssh $host "docker exec gl0 curl -sf -X POST http://127.0.0.1:9002/cluster/join \
              -H 'Content-Type: application/json' \
              -d '{\"id\": \"${GL0_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9001}'" || true
          done

          sleep 15

          # CRITICAL: Wait for GL0 cluster to be fully operational before proceeding
          # ML0 and all L1 layers depend on GL0 being stable
          echo "Waiting for GL0 cluster to reach 3 nodes..."
          for i in $(seq 1 60); do
            CLUSTER_SIZE=$(ssh node1 'curl -sf http://localhost:9000/cluster/info | jq length' || echo "0")
            echo "GL0 cluster size: $CLUSTER_SIZE (attempt $i/60)"
            if [ "$CLUSTER_SIZE" -ge 3 ]; then
              echo "âœ“ GL0 cluster has $CLUSTER_SIZE nodes"
              break
            fi
            if [ "$i" = "60" ]; then
              echo "::error::GL0 cluster failed to reach 3 nodes after 5 minutes"
              exit 1
            fi
            sleep 5
          done

          # Verify all GL0 nodes are Ready (with retries - nodes may still be syncing)
          echo "Verifying all GL0 nodes are Ready..."
          for host in node1 node2 node3; do
            echo "Waiting for GL0 on $host to reach Ready..."
            for attempt in $(seq 1 60); do
              STATE=$(ssh $host 'curl -sf http://localhost:9000/node/info | jq -r .state' || echo "DOWN")
              if [ "$STATE" = "Ready" ]; then
                echo "âœ“ GL0 $host is Ready"
                break
              fi
              if [ "$attempt" = "60" ]; then
                echo "::error::GL0 on $host failed to reach Ready after 5 minutes (state: $STATE)"
                ssh $host 'docker logs gl0 2>&1 | tail -30' || true
                exit 1
              fi
              echo "GL0 $host: $STATE (attempt $attempt/60)"
              sleep 5
            done
          done
          echo "âœ… GL0 cluster fully operational (3/3 Ready)"

      - name: Start GL1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # IS_INITIAL=true for first GL1 - auto-detects run-initial-validator vs run-validator
          ssh node1 << EOF
          docker run -d --name gl1 \
            --restart unless-stopped \
            --log-opt max-size=100m --log-opt max-file=3 \
            -p 9100:9100 -p 9101:9101 -p 9102:9102 \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/gl1-data:/ottochain/data \
            -v /opt/ottochain/gl1-logs:/tessellation/logs \
            -e LAYER=gl1 \
            -e IS_INITIAL=true \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            -e CL_COLLATERAL=0 \
            -e CL_L0_PEER_ID=${GL0_PEER_ID} \
            -e CL_L0_PEER_HOST=${NODE1_IP} \
            -e CL_L0_PEER_PORT=9000 \
            -e CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }} \
            -e JAVA_OPTS="-Xmx4g -Xms2g" \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}
          EOF

          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9100/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then break; fi
            sleep 5
          done

          GL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9100/node/info | jq -r .id' || echo "")

          # CRITICAL: Each node needs a DIFFERENT key for consensus
          # node2 uses keys2, node3 uses keys3
          for host_info in "node2:${NODE2_IP}:keys2" "node3:${NODE3_IP}:keys3"; do
            HOST="${host_info%%:*}"
            rest="${host_info#*:}"
            IP="${rest%%:*}"
            KEYS="${rest##*:}"
            # IS_INITIAL not set = auto-detects run-validator
            ssh $HOST "docker run -d --name gl1 \
              --restart unless-stopped \
              --log-opt max-size=100m --log-opt max-file=3 \
              -p 9100:9100 -p 9101:9101 -p 9102:9102 \
              -v /opt/ottochain/${KEYS}:/ottochain/keys:ro \
              -v /opt/ottochain/gl1-data:/ottochain/data \
              -v /opt/ottochain/gl1-logs:/tessellation/logs \
              -e LAYER=gl1 \
              -e CL_APP_ENV=dev \
              -e CL_EXTERNAL_IP=${IP} \
              -e CL_COLLATERAL=0 \
              -e CL_L0_PEER_ID=${GL0_PEER_ID} \
              -e CL_L0_PEER_HOST=${NODE1_IP} \
              -e CL_L0_PEER_PORT=9000 \
              -e CL_PASSWORD=${{ secrets.CL_KEYSTORE_PASSWORD }} \
              -e JAVA_OPTS='-Xmx4g -Xms2g' \
              ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"
          done

          sleep 20

          if [ -n "$GL1_PEER_ID" ] && [ "$GL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              ssh $host "docker exec gl1 curl -sf -X POST http://127.0.0.1:9102/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${GL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9101}'" || true
            done
          fi

      # In tessellation v4.x, create-genesis requires GL0 to be running
      - name: Create ML0 genesis snapshot
        if: ${{ steps.genesis-check.outputs.needs_genesis == 'true' }}
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          
          # Clean ML0 data directories on ALL nodes before genesis
          # This prevents ordinal collisions from partial prior runs
          echo "Cleaning ML0 data directories on all nodes..."
          for host in node1 node2 node3; do
            ssh $host 'rm -rf /opt/ottochain/data/ml0 /opt/ottochain/data/cl1 /opt/ottochain/data/dl1 2>/dev/null || true'
            ssh $host 'mkdir -p /opt/ottochain/data'
            ssh $host 'sync'  # Force disk sync
            echo "âœ“ $host ML0/CL1/DL1 data cleaned"
          done
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # Download tessellation cl-wallet.jar v4.x if not present (has show-address/show-id commands)
          ssh node1 "test -f /opt/ottochain/cl-wallet.jar || curl -sL -o /opt/ottochain/cl-wallet.jar \
            https://github.com/Constellation-Labs/tessellation/releases/download/v4.0.0-rc.2/cl-wallet.jar"

          # Get wallet address from keystore using cl-wallet
          echo "Getting wallet address..."
          WALLET=$(ssh node1 "CL_KEYSTORE=/opt/ottochain/keys/key.p12 CL_KEYALIAS=alias CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            java -jar /opt/ottochain/cl-wallet.jar show-address" 2>&1 | grep -oP 'DAG[a-zA-Z0-9]+' | head -1)

          if [ -z "$WALLET" ]; then
            echo "âŒ Failed to get wallet address"
            exit 1
          fi
          echo "Wallet address: $WALLET"

          # Create genesis.csv with initial token allocation
          ssh node1 "echo '${WALLET},1000000000000000' > /opt/ottochain/genesis/genesis.csv"
          echo "Genesis CSV:"
          ssh node1 "cat /opt/ottochain/genesis/genesis.csv"

          # Run create-genesis with GL0 running (required in tessellation v4.x)
          # The command connects to GL0 to fetch the current global snapshot
          echo "Creating genesis snapshot (GL0 must be running)..."
          ssh node1 "docker run --rm \
            --network host \
            --entrypoint '' \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/genesis:/ottochain/genesis \
            -w /ottochain/genesis \
            -e CL_KEYSTORE=/ottochain/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
            -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
            -e CL_PUBLIC_HTTP_PORT=9200 \
            -e CL_P2P_HTTP_PORT=9201 \
            -e CL_CLI_HTTP_PORT=9202 \
            -e CL_COLLATERAL=0 \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }} \
            java -jar /ottochain/jars/ml0.jar create-genesis /ottochain/genesis/genesis.csv"

          # Verify genesis was created successfully
          echo "Verifying ML0 genesis files..."
          if ! ssh node1 "test -f /opt/ottochain/genesis/genesis.snapshot"; then
            echo "::error::genesis.snapshot not found - ML0 genesis creation failed"
            exit 1
          fi
          if ! ssh node1 "test -f /opt/ottochain/genesis/genesis.address"; then
            echo "::error::genesis.address not found - ML0 genesis creation failed"
            exit 1
          fi
          ssh node1 "ls -la /opt/ottochain/genesis/"
          echo "Genesis address: $(ssh node1 'cat /opt/ottochain/genesis/genesis.address')"
          
          # Distribute genesis files to all nodes (validators need genesis.address for TOKEN_ID)
          echo "Distributing genesis files to node2 and node3..."
          for host in node2 node3; do
            ssh $host "mkdir -p /opt/ottochain/genesis"
            # Copy essential genesis files
            ssh node1 'cat /opt/ottochain/genesis/genesis.address' | ssh $host 'cat > /opt/ottochain/genesis/genesis.address'
            ssh node1 'cat /opt/ottochain/genesis/genesis.csv' | ssh $host 'cat > /opt/ottochain/genesis/genesis.csv'
            echo "âœ“ Genesis files copied to $host"
          done
          echo "âœ… ML0 genesis snapshot created, verified, and distributed"

      - name: Start ML0
        id: start-ml0
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"

          # Use entrypoint with IS_INITIAL=true - auto-detects run-genesis vs run-rollback
          # Genesis file at /ottochain/genesis/genesis.snapshot is auto-discovered
          ssh node1 "docker run -d --name ml0 \
            --restart unless-stopped \
            --log-opt max-size=100m --log-opt max-file=3 \
            -p 9200:9200 -p 9201:9201 -p 9202:9202 \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/ml0-data:/ottochain/data \
            -v /opt/ottochain/ml0-logs:/tessellation/logs \
            -v /opt/ottochain/genesis:/ottochain/genesis:ro \
            -e LAYER=ml0 \
            -e IS_INITIAL=true \
            -e CL_KEYSTORE=/ottochain/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            -e CL_COLLATERAL=0 \
            -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
            -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
            -e JAVA_OPTS='-Xmx8g -Xms4g' \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"

          echo "Waiting for ML0 to become Ready..."
          for i in $(seq 1 90); do
            state=$(ssh node1 'curl -sf http://localhost:9200/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then
              echo "ML0 Ready after $((i*5))s"
              break
            fi
            if [ "$i" = "90" ]; then echo "::error::ML0 failed to reach Ready"; exit 1; fi
            sleep 5
          done

          ML0_PEER_ID=$(ssh node1 'curl -sf http://localhost:9200/node/info | jq -r .id')
          echo "ml0_peer_id=$ML0_PEER_ID" >> "$GITHUB_OUTPUT"

          # v4.x doesn't expose .address in /node/info, read from genesis file
          TOKEN_ID=$(ssh node1 'cat /opt/ottochain/genesis/genesis.address')
          echo "token_id=$TOKEN_ID" >> "$GITHUB_OUTPUT"
          echo "Token ID: $TOKEN_ID"
          
          # Wipe ML0-specific data directories on node2/node3 before starting validators
          # They should sync fresh from node1, not inherit stale/partial state from failed syncs
          # Use a dedicated ml0-data directory to avoid affecting GL0/GL1
          echo "Preparing clean ML0 data directories on node2/node3..."
          for host in node2 node3; do
            ssh $host 'rm -rf /opt/ottochain/ml0-data && mkdir -p /opt/ottochain/ml0-data && sync'
            echo "âœ“ $host ML0 data directory prepared"
          done

          # CRITICAL: Each node needs a DIFFERENT key for consensus
          # node2 uses keys2, node3 uses keys3
          for host_info in "node2:${NODE2_IP}:keys2" "node3:${NODE3_IP}:keys3"; do
            HOST="${host_info%%:*}"
            rest="${host_info#*:}"
            IP="${rest%%:*}"
            KEYS="${rest##*:}"
            # IS_INITIAL not set = auto-detects run-validator
            ssh $HOST "docker run -d --name ml0 \
              --restart unless-stopped \
              --log-opt max-size=100m --log-opt max-file=3 \
              -p 9200:9200 -p 9201:9201 -p 9202:9202 \
              -v /opt/ottochain/${KEYS}:/ottochain/keys:ro \
              -v /opt/ottochain/ml0-data:/ottochain/data \
              -v /opt/ottochain/ml0-logs:/tessellation/logs \
              -e LAYER=ml0 \
              -e CL_KEYSTORE=/ottochain/keys/key.p12 \
              -e CL_KEYALIAS=alias \
              -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
              -e CL_APP_ENV=dev \
              -e CL_EXTERNAL_IP=${IP} \
              -e CL_COLLATERAL=0 \
              -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
              -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
              -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
              -e CL_TOKEN_ID=${TOKEN_ID} \
              -e JAVA_OPTS='-Xmx8g -Xms4g' \
              ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"
          done

          sleep 25

          # Wait for ML0 validators to reach ReadyToJoin state before attempting join
          echo "Waiting for ML0 validators to reach ReadyToJoin state..."
          for host in node2 node3; do
            for i in $(seq 1 30); do
              STATE=$(ssh "$host" 'curl -sf http://localhost:9200/node/state 2>/dev/null | tr -d \"' || echo "unknown")
              echo "$host ML0 state: $STATE (attempt $i/30)"
              if [ "$STATE" = "ReadyToJoin" ] || [ "$STATE" = "Observing" ] || [ "$STATE" = "Ready" ]; then
                echo "âœ“ $host ML0 ready"
                break
              fi
              if [ "$i" = "30" ]; then
                echo "::warning::$host ML0 did not reach ReadyToJoin state (current: $STATE)"
              fi
              sleep 5
            done
          done

          # Join ML0 validators to cluster
          echo "Joining ML0 validators to cluster..."
          echo "ML0_PEER_ID: ${ML0_PEER_ID:0:32}..."
          echo "NODE1_IP: ${NODE1_IP}"
          
          # Build join payload once (expands variables locally)
          JOIN_PAYLOAD=$(printf '{"id": "%s", "ip": "%s", "p2pPort": 9201}' "$ML0_PEER_ID" "$NODE1_IP")
          echo "JOIN_PAYLOAD: $JOIN_PAYLOAD"
          
          for host in node2 node3; do
            echo "Joining $host ML0..."
            # Pass pre-built payload to avoid quoting issues
            if ssh "$host" "docker exec ml0 curl -sf -X POST http://127.0.0.1:9202/cluster/join -H 'Content-Type: application/json' -d '$JOIN_PAYLOAD'"; then
              echo "âœ“ $host ML0 join initiated"
            else
              echo "âš  $host ML0 join failed (may already be joined)"
            fi
          done
          
          # CRITICAL: Wait for ML0 cluster to be fully operational before proceeding
          # CL1 and DL1 depend on ML0 being stable
          echo "Waiting for ML0 cluster to reach 3 nodes..."
          for i in $(seq 1 60); do
            ML0_CLUSTER_SIZE=$(ssh node1 'curl -sf http://localhost:9200/cluster/info | jq length' || echo "0")
            echo "ML0 cluster size: $ML0_CLUSTER_SIZE (attempt $i/60)"
            if [ "$ML0_CLUSTER_SIZE" -ge 3 ]; then
              echo "âœ“ ML0 cluster has $ML0_CLUSTER_SIZE nodes"
              break
            fi
            if [ "$i" = "60" ]; then
              echo "::error::ML0 cluster failed to reach 3 nodes after 5 minutes"
              # Log node states for debugging
              for host in node1 node2 node3; do
                STATE=$(ssh $host 'curl -sf http://localhost:9200/node/info | jq -r .state' 2>/dev/null || echo "DOWN")
                echo "ML0 $host: $STATE"
                # Check for ordinal errors in logs
                ssh $host 'docker logs ml0 2>&1 | tail -20 | grep -i "ordinal\|error" || true'
              done
              exit 1
            fi
            sleep 5
          done

          # Verify all ML0 nodes are Ready (with retries - nodes may still be syncing)
          echo "Verifying all ML0 nodes are Ready..."
          for host in node1 node2 node3; do
            echo "Waiting for ML0 on $host to reach Ready..."
            for attempt in $(seq 1 60); do
              STATE=$(ssh $host 'curl -sf http://localhost:9200/node/info | jq -r .state' || echo "DOWN")
              if [ "$STATE" = "Ready" ]; then
                echo "âœ“ ML0 $host is Ready"
                break
              fi
              if [ "$attempt" = "60" ]; then
                echo "::error::ML0 on $host failed to reach Ready after 5 minutes (state: $STATE)"
                ssh $host 'docker logs ml0 2>&1 | tail -30' || true
                exit 1
              fi
              echo "ML0 $host: $STATE (attempt $attempt/60)"
              sleep 5
            done
          done
          echo "âœ… ML0 cluster fully operational (3/3 Ready)"

      - name: Start CL1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"
          ML0_PEER_ID="${{ steps.start-ml0.outputs.ml0_peer_id }}"
          TOKEN_ID=$(ssh node1 'cat /opt/ottochain/genesis/genesis.address')
          echo "Token ID: $TOKEN_ID"

          # IS_INITIAL=true for first CL1 - auto-detects run-initial-validator vs run-validator
          ssh node1 "docker run -d --name cl1 \
            --restart unless-stopped \
            --log-opt max-size=100m --log-opt max-file=3 \
            -p 9300:9300 -p 9301:9301 -p 9302:9302 \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/cl1-data:/ottochain/data \
            -v /opt/ottochain/cl1-logs:/tessellation/logs \
            -e LAYER=cl1 \
            -e IS_INITIAL=true \
            -e CL_KEYSTORE=/ottochain/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            -e CL_COLLATERAL=0 \
            -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
            -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
            -e CL_L0_PEER_ID=${ML0_PEER_ID} \
            -e CL_L0_PEER_HOST=${NODE1_IP} \
            -e CL_L0_PEER_PORT=9200 \
            -e CL_TOKEN_ID=${TOKEN_ID} \
            -e JAVA_OPTS='-Xmx4g -Xms2g' \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"

          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9300/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then break; fi
            sleep 5
          done

          CL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9300/node/info | jq -r .id' || echo "")

          # CRITICAL: Each L1 node needs a DIFFERENT key for consensus
          # node2 uses keys2, node3 uses keys3
          for host_info in "node2:${NODE2_IP}:keys2" "node3:${NODE3_IP}:keys3"; do
            HOST="${host_info%%:*}"
            rest="${host_info#*:}"
            IP="${rest%%:*}"
            KEYS="${rest##*:}"
            # IS_INITIAL not set = auto-detects run-validator
            ssh $HOST "docker run -d --name cl1 \
              --restart unless-stopped \
              --log-opt max-size=100m --log-opt max-file=3 \
              -p 9300:9300 -p 9301:9301 -p 9302:9302 \
              -v /opt/ottochain/${KEYS}:/ottochain/keys:ro \
              -v /opt/ottochain/cl1-data:/ottochain/data \
              -v /opt/ottochain/cl1-logs:/tessellation/logs \
              -e LAYER=cl1 \
              -e CL_KEYSTORE=/ottochain/keys/key.p12 \
              -e CL_KEYALIAS=alias \
              -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
              -e CL_APP_ENV=dev \
              -e CL_EXTERNAL_IP=${IP} \
              -e CL_COLLATERAL=0 \
              -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
              -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
              -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
              -e CL_L0_PEER_ID=${ML0_PEER_ID} \
              -e CL_L0_PEER_HOST=${NODE1_IP} \
              -e CL_L0_PEER_PORT=9200 \
              -e CL_TOKEN_ID=${TOKEN_ID} \
              -e JAVA_OPTS='-Xmx4g -Xms2g' \
              ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"
          done

          sleep 25

          if [ -n "$CL1_PEER_ID" ] && [ "$CL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              ssh $host "docker exec cl1 curl -sf -X POST http://127.0.0.1:9302/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${CL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9301}'" || true
            done
          fi

      - name: Start DL1
        run: |
          NODE1_IP="${{ secrets.HETZNER_NODE1_IP }}"
          NODE2_IP="${{ secrets.HETZNER_NODE2_IP }}"
          NODE3_IP="${{ secrets.HETZNER_NODE3_IP }}"
          GL0_PEER_ID="${{ steps.start-gl0.outputs.gl0_peer_id }}"
          ML0_PEER_ID="${{ steps.start-ml0.outputs.ml0_peer_id }}"
          TOKEN_ID=$(ssh node1 'cat /opt/ottochain/genesis/genesis.address')

          # IS_INITIAL=true for first DL1 - auto-detects run-initial-validator vs run-validator
          ssh node1 "docker run -d --name dl1 \
            --restart unless-stopped \
            --log-opt max-size=100m --log-opt max-file=3 \
            -p 9400:9400 -p 9401:9401 -p 9402:9402 \
            -v /opt/ottochain/keys:/ottochain/keys:ro \
            -v /opt/ottochain/dl1-data:/ottochain/data \
            -v /opt/ottochain/dl1-logs:/tessellation/logs \
            -e LAYER=dl1 \
            -e IS_INITIAL=true \
            -e CL_KEYSTORE=/ottochain/keys/key.p12 \
            -e CL_KEYALIAS=alias \
            -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
            -e CL_APP_ENV=dev \
            -e CL_EXTERNAL_IP=${NODE1_IP} \
            -e CL_COLLATERAL=0 \
            -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
            -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
            -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
            -e CL_L0_PEER_ID=${ML0_PEER_ID} \
            -e CL_L0_PEER_HOST=${NODE1_IP} \
            -e CL_L0_PEER_PORT=9200 \
            -e CL_TOKEN_ID=${TOKEN_ID} \
            -e JAVA_OPTS='-Xmx4g -Xms2g' \
            ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"

          for i in $(seq 1 60); do
            state=$(ssh node1 'curl -sf http://localhost:9400/node/info | jq -r .state' || echo "")
            if [ "$state" = "Ready" ]; then break; fi
            sleep 5
          done

          DL1_PEER_ID=$(ssh node1 'curl -sf http://localhost:9400/node/info | jq -r .id' || echo "")

          # CRITICAL: Each L1 node needs a DIFFERENT key for consensus
          # node2 uses keys2, node3 uses keys3
          for host_info in "node2:${NODE2_IP}:keys2" "node3:${NODE3_IP}:keys3"; do
            HOST="${host_info%%:*}"
            rest="${host_info#*:}"
            IP="${rest%%:*}"
            KEYS="${rest##*:}"
            # IS_INITIAL not set = auto-detects run-validator
            ssh $HOST "docker run -d --name dl1 \
              --restart unless-stopped \
              --log-opt max-size=100m --log-opt max-file=3 \
              -p 9400:9400 -p 9401:9401 -p 9402:9402 \
              -v /opt/ottochain/${KEYS}:/ottochain/keys:ro \
              -v /opt/ottochain/dl1-data:/ottochain/data \
              -v /opt/ottochain/dl1-logs:/tessellation/logs \
              -e LAYER=dl1 \
              -e CL_KEYSTORE=/ottochain/keys/key.p12 \
              -e CL_KEYALIAS=alias \
              -e CL_PASSWORD='${{ secrets.CL_KEYSTORE_PASSWORD }}' \
              -e CL_APP_ENV=dev \
              -e CL_EXTERNAL_IP=${IP} \
              -e CL_COLLATERAL=0 \
              -e CL_GLOBAL_L0_PEER_ID=${GL0_PEER_ID} \
              -e CL_GLOBAL_L0_PEER_HTTP_HOST=${NODE1_IP} \
              -e CL_GLOBAL_L0_PEER_HTTP_PORT=9000 \
              -e CL_L0_PEER_ID=${ML0_PEER_ID} \
              -e CL_L0_PEER_HOST=${NODE1_IP} \
              -e CL_L0_PEER_PORT=9200 \
              -e CL_TOKEN_ID=${TOKEN_ID} \
              -e JAVA_OPTS='-Xmx4g -Xms2g' \
              ${{ env.IMAGE }}:${{ env.IMAGE_TAG }}"
          done

          sleep 25

          if [ -n "$DL1_PEER_ID" ] && [ "$DL1_PEER_ID" != "null" ]; then
            for host in node2 node3; do
              ssh $host "docker exec dl1 curl -sf -X POST http://127.0.0.1:9402/cluster/join \
                -H 'Content-Type: application/json' \
                -d '{\"id\": \"${DL1_PEER_ID}\", \"ip\": \"${NODE1_IP}\", \"p2pPort\": 9401}'" || true
            done
          fi

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/hetzner
          chmod 600 ~/.ssh/hetzner
          for host in node1 node2 node3; do
            case $host in
              node1) ip="${{ secrets.HETZNER_NODE1_IP }}" ;;
              node2) ip="${{ secrets.HETZNER_NODE2_IP }}" ;;
              node3) ip="${{ secrets.HETZNER_NODE3_IP }}" ;;
            esac
            cat >> ~/.ssh/config << EOF
          Host $host
            HostName $ip
            User root
            IdentityFile ~/.ssh/hetzner
            StrictHostKeyChecking no
          EOF
          done

      - name: Check all layers
        run: |
          echo "=== OttoChain 5-Layer Cluster Health ==="
          FAILED=0

          for layer in gl0 gl1 ml0 cl1 dl1; do
            case $layer in
              gl0) port=9000 ;; gl1) port=9100 ;; ml0) port=9200 ;; cl1) port=9300 ;; dl1) port=9400 ;;
            esac
            state=$(ssh node1 "curl -sf http://localhost:$port/node/info | jq -r .state" || echo "DOWN")
            cluster=$(ssh node1 "curl -sf http://localhost:$port/cluster/info | jq length" || echo "0")
            STATUS="âœ…"
            if [ "$state" != "Ready" ]; then STATUS="âŒ"; FAILED=$((FAILED + 1)); fi
            echo "$STATUS $layer: $state (cluster: $cluster)"
          done

          if [ "$FAILED" -gt 0 ]; then echo "::warning::$FAILED layer(s) not Ready"; fi

      - name: Verify L1 peer ID uniqueness
        run: |
          echo "=== Verifying L1 nodes have unique peer IDs ==="
          
          # Collect DL1 peer IDs from all nodes
          DL1_1=$(ssh node1 "curl -sf http://localhost:9400/node/info | jq -r .id" || echo "error")
          DL1_2=$(ssh node2 "curl -sf http://localhost:9400/node/info | jq -r .id" || echo "error")
          DL1_3=$(ssh node3 "curl -sf http://localhost:9400/node/info | jq -r .id" || echo "error")
          
          echo "DL1 node1: ${DL1_1:0:32}..."
          echo "DL1 node2: ${DL1_2:0:32}..."
          echo "DL1 node3: ${DL1_3:0:32}..."
          
          if [ "$DL1_1" = "$DL1_2" ] || [ "$DL1_1" = "$DL1_3" ] || [ "$DL1_2" = "$DL1_3" ]; then
            echo "::error::DL1 nodes have DUPLICATE peer IDs! L1 consensus will fail."
            echo "This means nodes are using the same key.p12 file."
            exit 1
          fi
          
          echo "âœ“ All DL1 nodes have unique peer IDs - consensus should work"

      - name: Summary
        run: |
          echo "## ðŸš€ Metagraph Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image**: \`${{ env.IMAGE }}:${{ env.IMAGE_TAG }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Layer | Port | State | Cluster |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|-------|---------|" >> $GITHUB_STEP_SUMMARY

          for layer in GL0 GL1 ML0 CL1 DL1; do
            case $layer in
              GL0) port=9000 ;; GL1) port=9100 ;; ML0) port=9200 ;; CL1) port=9300 ;; DL1) port=9400 ;;
            esac
            state=$(ssh node1 "curl -sf http://localhost:$port/node/info | jq -r .state" 2>/dev/null || echo "?")
            cluster=$(ssh node1 "curl -sf http://localhost:$port/cluster/info | jq length" 2>/dev/null || echo "?")
            ICON="âœ…"; [ "$state" != "Ready" ] && ICON="âŒ"
            echo "| $ICON $layer | $port | $state | $cluster |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**GL0 Peer ID**: \`${{ needs.deploy.outputs.gl0_peer_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**ML0 Peer ID**: \`${{ needs.deploy.outputs.ml0_peer_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Token ID**: \`${{ needs.deploy.outputs.token_id }}\`" >> $GITHUB_STEP_SUMMARY
